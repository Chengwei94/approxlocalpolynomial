# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' This function is used to estimate the curve using local linear 
#' implemented in C++ for faster efficiency 
#'
#' @para XY_mat: Matrix of both X and Y with Y in the last colum 
#' @para method: 1 for exact, 2 for approximate 
#' @para kcode: Choice of kernel
#' @para epsilon: Range allowed for approximate 
#' @para bw: Matrix of bandwidth 
#' @param N_min: Number of values allowed in the leaf of the tree:
#' larger nodes stored result in less accuracy 
#' @export
#' @examples 
#' std::cout << loclinear_i(test1, 2, 1, 0.05, h, 1) where h is a vector of bandwidth
NULL

#' This function is used to select bandwidth given a matrix of bandwidths 
#' implemented in C++ for faster efficiency 
#'
#' @para XY_mat: Matrix of both X and Y with Y in the last colum 
#' @para method: 1 for exact, 2 for approximate 
#' @para kcode: Choice of kernel
#' @para epsilon: Range allowed for approximate 
#' @para bw: Matrix of bandwidth 
#' @param N_min: Number of values allowed in the leaf of the tree:
#' larger nodes stored result in less accuracy 
#' @export
#' @examples 
#' std::cout << h_select_i(test1, 2, 1, 0.05, h, 1) where h is a vector of bandwidth
NULL

loclinear_i <- function(XY_mat, method, kcode, epsilon, h, N_min) {
    .Call('_localweightedreg_loclinear_i', PACKAGE = 'localweightedreg', XY_mat, method, kcode, epsilon, h, N_min)
}

predict_i <- function(XY_mat, Xpred_mat, method, kcode, epsilon, h, N_min) {
    .Call('_localweightedreg_predict_i', PACKAGE = 'localweightedreg', XY_mat, Xpred_mat, method, kcode, epsilon, h, N_min)
}

h_select_i <- function(XY_mat, method, kcode, epsilon, bw, N_min) {
    .Call('_localweightedreg_h_select_i', PACKAGE = 'localweightedreg', XY_mat, method, kcode, epsilon, bw, N_min)
}

